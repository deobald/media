
# Case Study: Insider.in

PayTM Insider is India's largest online ticketing and events company. Insider approached nilenso in early 2018 with a concept for an entirely new business model. Millions of fans already attend Insider's live events. Insider wanted to bring those events online. Could nilenso help them host online events -- with software hosting all those millions of fans _at once_?

It wasn't a foregone conclusion that we could build such a system. We certainly had never built one like it before. Even software like Twitch.tv, dedicated to streaming video to simultaneous users, lives in the realm of "millions of simultaneous users". Even Insider's live events, such as NH7 Weekender, were known to draw crowds large enough to bring commercial telecommunications infrastructure to its knees. Building a platform to host even larger online events? We were intrigued.

The project began with the disarmingly simple problem statement: "Stream video to one million concurrent users." Outside of a real emergency, we would never normally work weekends, but we had worked with the team from Insider before and we were just as excited as they were about solving this puzzle. We spent that first weekend split into teams, battling a GoLang prototype against an Elixir prototype. (By which, we really mean Erlang... by which, we really mean BEAM and ERTS, Erlang's Virtual Machine and Runtime. We'll get to that later, though.) Our usual weapon of choice, Clojure, wasn't a good fit for a system that demanded one million simultaneous connections because the JVM's scaling models were simply too heavy. GoLang has some wonderful concurrency primitives, but they proved no match for Erlang's ultralightweight processes and in-your-face distributed systems approach. By the end of the weekend, Elixir had won the brawl and the project had a name: _ngage_.

Building on the Erlang runtime meant distributed systems were baked into every component and, while the team was very experienced with distributed systems and the Patterns of Enterprise Application Architecture, our past toolkits rarely _enforced_ message-passing. BEAM (and therefore, Elixir) declare, existentially, that message-passing and process boundaries (and thus their inverse: process size), are the primary considerations of system design. To build a functional system on BEAM at all, you must build a distributed system. Over the first few weeks of the project, the team deeply embedded themselves in Erlang runtime's message-passing paradigm --- learning, experimenting, and exploring along the way. The team had chosen Elixir precisely for its runtime and when it was time to load test the system, the distributed-system-up-front model had already proven itself.

Load testing is an exercise delineated by orders of magnitude. It becomes a non-trivial task when simulating concurrent users ordering in the hundreds of thousands. The team nicknamed these thousands of gossamer androids "The Mob"... built to swarm _ngage_ with parallel but uncoordinated activity and break the system in the safety of a sandbox. The Mob Simulator (_mobsim_) would continuously test _ngage_, looking for weaknesses in its distributed design, in turn helping the team carve out the all-important process boundaries. Neena would eventually transform the lessons from these iterations into a talk on the BEAM Virtual Machine.

- simulation framework
- transcoding delays
- self PM / new PM
- "summary" / Beta 1
- Beta 2
- Travel to Bombay

- Poll format
- Erlang = yay
- simulation framework
- transition to in-house team

The software industry frequently reaches for descriptions like "challenging work" and "world-class developers"... frequently enough that these words have become meaningless. There exists a dichotomy in the world of software consulting that we often fumble to clearly describe. On one hand, some custom software lives in the world of the _bespoke_. A good tailor does not reinvent the craft of tailoring every time he cuts a new suit. Similarly, the three million apps on the Stores for iOS and Android largely don't represent revolutions in Computer Science. Humanity isn't the proud custodian of billions of web apps because they each represent a brainchild of software engineering's avant-garde. Software in the 21st Century is wildly democratic, which is wonderful because a developer doesn't have the energy to rediscover the very definition of a mobile app every time she writes one. On the other hand, however, there exist software projects which are truly experimental and genuinely difficult. This was one such project.
